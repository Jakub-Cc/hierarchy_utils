package visual_clustering.parser;

import common.CmdLineParser;
import common.Parameters;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.OptionBuilder;
import visual_clustering.parameters.PruneHierarchyAndPerformHkOnLeavesParameters;

import java.util.LinkedList;

public class PruneHierarchyAndPerformHkOnLeavesParser extends CmdLineParser {
    private final static String[] hkOptions = {"o", "k", "n", "r", "s", "e", "l", "w", "rf", "cf", "gi", "h", "km",
            "gmm", "lgmm", "v", "c", "in", "ds", "scrs", "scac", "sccs", "dm", "re"};
    public PruneHierarchyAndPerformHkOnLeavesParser() {
        super();
    }

    @Override
    protected void createOptions() {
        Option input = OptionBuilder.withArgName("file")
                .hasArgs(1)
                .isRequired(true)
                .withDescription("path to file with input OCH")
                .withLongOpt("input")
                .create('i');

        Option output = OptionBuilder.withArgName("path")
                .hasArgs(1)
                .isRequired(true)
                .withDescription("path where to store results. ")
                .withLongOpt("output")
                .create('o');

        Option methodPath = OptionBuilder.withArgName("path")
                .hasArgs(1)
                .isRequired(true)
                .withDescription("path to *.jar file with the method. ")
                .withLongOpt("method-path")
                .create("mp");

        Option cut = OptionBuilder.withArgName("number")
                .hasArgs(1)
                .isRequired(true)
                .withDescription("Height at which the cut should be performed to generate leaves. On the resulting leaves" +
                        " the method is going to be invoked.")
                .withLongOpt("cut-height")
                .create("ch");

        Option help = OptionBuilder.withDescription("prints this message")
                .hasArg(false)
                .isRequired(false)
                .withLongOpt("help")
                .create('h');

        options.addOption("c", "class-attribute", false, "indicates that FIRST column of data is class attribute, class shoud be indicated "
                + "by string. When class attribute is provided "
                + "then recall, precision and F-Measure will be calculated for each dendrogram level and for whole dednrogram. See \"Fast "
                + "and effective text mining using linear-time "
                + "document clustering\" by B. Larsen and C. Aone (1999)");
        options.addOption("in", "instance-name", false, "indicates that SECOND (if class attribute is present) or FIRST (otherwise) column"
                + " is the name of every instance.");

        options.addOption(input);
        options.addOption(output);
        options.addOption(methodPath);
        options.addOption(cut);
        options.addOption(help);

        addHkParameters();
    }

    private void addHkParameters() {
        Option k = OptionBuilder.withArgName("k")
                .hasArgs(1)
                .isRequired(false)
                .withDescription("number of clusters generated by clusterisation algorithm")
                .withLongOpt("clusters")
                .create('k');

        Option iterations = OptionBuilder.withArgName("iterations")
                .hasArgs(1)
                .withArgName("iterationNumber")
                .isRequired(false)
                .withDescription("number of maximum iterations made by clusterisation algorithm")
                .withLongOpt("number-of-iterations")
                .create('n');

        Option repeats = OptionBuilder.withArgName("repeats")
                .hasArgs(1)
                .withArgName("repeatsNumber")
                .isRequired(false)
                .withDescription("number of algorith repeats (new initialisation of clusters)")
                .withLongOpt("number-of-repeats")
                .create('r');

        Option dendrogramLevels = OptionBuilder.withArgName("dendrogram size")
                .hasArgs(1)
                .withArgName("dendrogramSize")
                .isRequired(false)
                .withDescription("max dendrogram height")
                .withLongOpt("dendrogram-size")
                .create('s');

        Option epsilon = OptionBuilder.withDescription("Epsilon value expressed as 10^-epsilon, used in comparing values to 0.0, reducing "
                + "round-off error. Default value is 10.")
                .hasOptionalArgs(1)
                .isRequired(false)
                .withArgName("epsilonValue")
                .withLongOpt("eps")
                .create('e');

        Option littleValue = OptionBuilder.withDescription("Value of diagonal matrix elements expressed as 10^-littleValue, used in forcing "
                + "covariance matrix to be non-singular. Default value is 5.")
                .hasOptionalArgs(1)
                .isRequired(false)
                .withArgName("littleValue")
                .withLongOpt("littleVal")
                .create('l');

        Option numberOfNodes = OptionBuilder.withDescription("Maximum number of created nodes.")
                .hasArgs(1)
                .isRequired(false)
                .withArgName("maxNumberOfNodes")
                .withLongOpt("maxNumOfNodes")
                .create('w');

        Option responsibilityScallingFactor = OptionBuilder.withDescription("Scalling factor of static center responsibility computation "
                + "values. In order to decrease it provide value in range (0;1).")
                .hasArgs(1)
                .isRequired(false)
                .withArgName("responsibilityScallingFactor")
                .withLongOpt("respSclFactor")
                .create("rf");

        Option covarianceScallingFactor = OptionBuilder.withDescription("Scalling factor of static center covariance set when derived to "
                + "lower levels. In order to increase it provide value in range (0;1).")
                .hasArgs(1)
                .isRequired(false)
                .withArgName("covarianceScallingFactor")
                .withLongOpt("covSclFactor")
                .create("cf");

        Option resultImagesSize = OptionBuilder.withDescription("store clusterisation results also as images (ONLY first two dimensions are"
                + " visualused!) the dimension of each image is SxS where S is the provided arguments value. Default is 800.")
                .hasOptionalArgs(1)
                .isRequired(false)
                .withArgName("generateImages")
                .withLongOpt("genImgs")
                .create("gi");

        options.addOption("km", "use-kmeans", false, "use kmeans clustering algorithm");
        options.addOption("gmm", "use-gaussian-mixture-model", false, "use gaussian-mixture-model clustering with expectation-maximisation");
        options.addOption("lgmm", "use-log-gaussian-mixture-model", false, "use gaussian-mixture-model clustering with expectation-maximisation that utilise logarithms"
                + " intead of direct probability representation. That change should increase the performance of method because of number underflows.");
        options.addOption("v", "verbose", false, "verbose program execution");
        options.addOption("ds", "disable-static-center", false, "disable feature of placing static (backgroud) center while going down in "
                + "hierarchy");
        options.addOption("scrs", "static-center-resposibility-scalling", false, "scale responibility value from static centers to points, "
                + "using value of resposibilityScallingFactor (f)");
        options.addOption("scac", "static-center-adaptive-covariance", false, "when deriving static center to lower level, its covariance "
                + "is scalled by factor 1/(prioriValue)");
        options.addOption("sccs", "static-center-covariance-scalling", false, "when deriving static center to lower level, its covariance "
                + "is scalled by factor 1/(covarianceScallingFactor)");
        options.addOption("dm", "diagonal-matrix", false, "use simple diagonal matrix instead of full matrix as a covariance matrix");
        options.addOption("re", "reestimate", false, "reestimate cluster centre and covariance matrix after EM finishes by using cluster "
                + "actual data");

        options.addOption(k);
        options.addOption(iterations);
        options.addOption(repeats);
        options.addOption(dendrogramLevels);
        options.addOption(epsilon);
        options.addOption(littleValue);
        options.addOption(numberOfNodes);
        options.addOption(responsibilityScallingFactor);
        options.addOption(covarianceScallingFactor);
        options.addOption(resultImagesSize);
    }

    @Override
    protected void parseParameters(Parameters paramsToSet) {
        PruneHierarchyAndPerformHkOnLeavesParameters params = (PruneHierarchyAndPerformHkOnLeavesParameters)paramsToSet;

        params.setInputHierarchy(parseInputFile());
        params.setOutputDir(parseOutputDirectory());
        params.setCutHeight(parsePositiveIntegerParameter(cmd.getOptionValue("ch"),
                "The height cut should be a positive integer number."));
        params.setMethodPath(parsePath("mp"));
        params.setContainsInstanceName(cmd.hasOption("in"));
        params.setContainsClassAttribute(cmd.hasOption("c"));
        params.setMethodInvocationCommandWithoutInput(parseHkInvocationCommandWithoutInputPath());
    }

    private LinkedList<String> parseHkInvocationCommandWithoutInputPath() {
        LinkedList<String> hkCommand = new LinkedList<>();
        hkCommand.add("java");
        hkCommand.add("-jar");
        hkCommand.add(cmd.getOptionValue("mp"));
        for(String option: hkOptions) {
            hkCommand.addAll(passHkOption(option));
        }
        return hkCommand;
    }

    private LinkedList<String> passHkOption(String optionName) {
        LinkedList<String> hkOptions = new LinkedList<>();
        if(cmd.hasOption(optionName)) {
            hkOptions.add("-" + optionName);

            String value = cmd.getOptionValue(optionName);
            if(value != null) {
                hkOptions.add(value);
            }
        }
        return hkOptions;
    }

}
